# æ™ºç³–ç®¡å®¶AI - åç«¯å¼€å‘ä»»åŠ¡

## ä½ çš„è§’è‰²
ä½ æ˜¯åç«¯å¼€å‘å·¥ç¨‹å¸ˆ,è´Ÿè´£æ­å»º"æ™ºç³–ç®¡å®¶AI"çš„å®Œæ•´åç«¯æœåŠ¡ç³»ç»Ÿã€‚

## é¡¹ç›®èƒŒæ™¯
- **å‰ç«¯çŠ¶æ€**: Reactåº”ç”¨å·²å®Œæˆ50%,ä½¿ç”¨mockæ•°æ®
- **ä½ çš„ä»»åŠ¡**: ä»é›¶æ­å»ºNode.js + Express + PostgreSQLåç«¯
- **å·¥ä½œç›®å½•**: `/home/devbox/project/backend/`(éœ€åˆ›å»º)
- **éƒ¨ç½²ç¯å¢ƒ**: Sealos Devbox (2CPU/4GB/40GB)

## æ ¸å¿ƒä»»åŠ¡æ¸…å•

### ä»»åŠ¡1: é¡¹ç›®åˆå§‹åŒ–ä¸åŸºç¡€æ¶æ„(ä¼˜å…ˆçº§:ğŸ”¥é«˜)

**æ­¥éª¤1: åˆ›å»ºé¡¹ç›®**
```bash
cd /home/devbox/project
mkdir backend && cd backend
npm init -y
```

**æ­¥éª¤2: å®‰è£…æ ¸å¿ƒä¾èµ–**
```bash
# ç”Ÿäº§ä¾èµ–
npm install express pg dotenv cors bcryptjs jsonwebtoken
npm install express-validator helmet compression morgan

# å¼€å‘ä¾èµ–
npm install -D typescript @types/node @types/express
npm install -D @types/bcryptjs @types/jsonwebtoken @types/cors
npm install -D ts-node nodemon
```

**æ­¥éª¤3: åˆå§‹åŒ–TypeScript**
```bash
npx tsc --init
```

ä¿®æ”¹`tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

**æ­¥éª¤4: åˆ›å»ºç›®å½•ç»“æ„**
```bash
mkdir -p src/{config,routes,controllers,services,middleware,utils}
touch src/app.ts .env .env.example .gitignore
```

**.gitignoreå†…å®¹**:
```
node_modules/
dist/
.env
*.log
```

**.env.exampleå†…å®¹**:
```env
# Server
PORT=3000
NODE_ENV=development

# PostgreSQL (ä»Sealosè·å–å®é™…å€¼)
DB_HOST=your_sealos_db_host
DB_PORT=5432
DB_NAME=sugarsmart_db
DB_USER=your_db_user
DB_PASSWORD=your_db_password

# JWT
JWT_SECRET=your_super_secret_key_change_in_production
JWT_EXPIRE=7d

# CORS
CORS_ORIGIN=http://localhost:5173

# AI (é¢„ç•™)
AI_PROVIDER=mock
AI_API_KEY=
```

**äº¤ä»˜æ ‡å‡†**:
- é¡¹ç›®ç»“æ„æ¸…æ™°
- ä¾èµ–å®‰è£…å®Œæˆ
- TypeScripté…ç½®æ­£ç¡®
- å¯ä»¥è¿è¡Œ`npm run dev`å¯åŠ¨å¼€å‘æœåŠ¡å™¨

---

### ä»»åŠ¡2: PostgreSQLæ•°æ®åº“è®¾è®¡ä¸è¿æ¥

**æ­¥éª¤1: é…ç½®æ•°æ®åº“è¿æ¥**

åˆ›å»º`src/config/database.ts`:
```typescript
import { Pool } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

export const pool = new Pool({
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

pool.on('connect', () => {
  console.log('âœ… PostgreSQL è¿æ¥æˆåŠŸ');
});

pool.on('error', (err) => {
  console.error('âŒ PostgreSQL è¿æ¥é”™è¯¯:', err);
  process.exit(-1);
});

export default pool;
```

**æ­¥éª¤2: åˆ›å»ºæ•°æ®è¡¨ç»“æ„**

åˆ›å»º`src/config/schema.sql`:
```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  wx_openid VARCHAR(255) UNIQUE,
  username VARCHAR(100) UNIQUE,
  password_hash VARCHAR(255),
  nickname VARCHAR(100),
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·æ¡£æ¡ˆè¡¨
CREATE TABLE IF NOT EXISTS user_profiles (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  age INTEGER NOT NULL,
  height DECIMAL(5,2) NOT NULL,
  weight DECIMAL(5,2) NOT NULL,
  gender VARCHAR(10) NOT NULL,
  diabetes_type VARCHAR(20) NOT NULL,
  fasting_glucose VARCHAR(10),
  medication TEXT,
  staple_food TEXT[],
  allergies TEXT[],
  meals_per_day INTEGER DEFAULT 3,
  special_requests TEXT,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id)
);

-- é¥®é£Ÿè®¡åˆ’è¡¨
CREATE TABLE IF NOT EXISTS meal_plans (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  plan_date DATE NOT NULL,
  recipes JSONB NOT NULL,
  total_calories INTEGER,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS idx_user_plan_date ON meal_plans(user_id, plan_date);

-- è¡€ç³–è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS glucose_records (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  record_date DATE NOT NULL,
  record_time TIME NOT NULL,
  record_type VARCHAR(20) NOT NULL,
  glucose_value DECIMAL(4,2) NOT NULL,
  note TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS idx_user_glucose_date ON glucose_records(user_id, record_date);

-- æ”¶è—é£Ÿè°±è¡¨
CREATE TABLE IF NOT EXISTS favorite_recipes (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  recipe_data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- èº«ä½“æŒ‡æ ‡è¡¨
CREATE TABLE IF NOT EXISTS body_metrics (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  metric_date DATE NOT NULL,
  weight DECIMAL(5,2),
  bmi DECIMAL(4,2),
  blood_pressure JSONB,
  blood_lipids JSONB,
  hba1c DECIMAL(4,2),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**æ­¥éª¤3: åˆ›å»ºæ•°æ®åº“åˆå§‹åŒ–è„šæœ¬**

åˆ›å»º`src/config/initDatabase.ts`:
```typescript
import { pool } from './database';
import fs from 'fs';
import path from 'path';

export async function initDatabase() {
  try {
    const schemaSQL = fs.readFileSync(
      path.join(__dirname, 'schema.sql'),
      'utf-8'
    );
    
    await pool.query(schemaSQL);
    console.log('âœ… æ•°æ®åº“è¡¨åˆ›å»ºæˆåŠŸ');
  } catch (error) {
    console.error('âŒ æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
    throw error;
  }
}
```

**äº¤ä»˜æ ‡å‡†**:
- æ•°æ®åº“è¿æ¥æˆåŠŸ
- æ‰€æœ‰è¡¨åˆ›å»ºå®Œæˆ
- å¯æ‰§è¡Œåˆå§‹åŒ–è„šæœ¬

---

### ä»»åŠ¡3: å®ç°æ ¸å¿ƒAPIæ¥å£

**æ­¥éª¤1: JWTè®¤è¯ä¸­é—´ä»¶**

åˆ›å»º`src/middleware/auth.ts`:
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthRequest extends Request {
  userId?: number;
}

export const authenticate = (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'æœªæä¾›è®¤è¯token'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: number };
    req.userId = decoded.userId;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ'
    });
  }
};
```

**æ­¥éª¤2: é”™è¯¯å¤„ç†ä¸­é—´ä»¶**

åˆ›å»º`src/middleware/errorHandler.ts`:
```typescript
import { Request, Response, NextFunction } from 'express';

export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error('Error:', err);

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'æ•°æ®éªŒè¯å¤±è´¥',
      errors: err.errors
    });
  }

  if (err.code === '23505') {
    return res.status(409).json({
      success: false,
      message: 'æ•°æ®å·²å­˜åœ¨'
    });
  }

  res.status(err.status || 500).json({
    success: false,
    message: err.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
  });
};
```

**æ­¥éª¤3: ç”¨æˆ·è®¤è¯API**

åˆ›å»º`src/controllers/authController.ts`:
```typescript
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { pool } from '../config/database';

export const register = async (req: Request, res: Response) => {
  try {
    const { username, password, nickname } = req.body;
    
    // éªŒè¯å¿…å¡«å­—æ®µ
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º'
      });
    }

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await pool.query(
      'SELECT id FROM users WHERE username = $1',
      [username]
    );
    
    if (existingUser.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'ç”¨æˆ·åå·²å­˜åœ¨'
      });
    }
    
    // åŠ å¯†å¯†ç 
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // åˆ›å»ºç”¨æˆ·
    const result = await pool.query(
      `INSERT INTO users (username, password_hash, nickname) 
       VALUES ($1, $2, $3) 
       RETURNING id, username, nickname, created_at`,
      [username, hashedPassword, nickname || username]
    );
    
    const user = result.rows[0];
    
    // ç”Ÿæˆtoken
    const token = jwt.sign(
      { userId: user.id },
      process.env.JWT_SECRET!,
      { expiresIn: process.env.JWT_EXPIRE || '7d' }
    );
    
    res.status(201).json({
      success: true,
      data: { 
        user: {
          id: user.id,
          username: user.username,
          nickname: user.nickname
        }, 
        token 
      }
    });
  } catch (error) {
    console.error('æ³¨å†Œé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};

export const login = async (req: Request, res: Response) => {
  try {
    const { username, password } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({
        success: false,
        message: 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º'
      });
    }

    // æŸ¥æ‰¾ç”¨æˆ·
    const result = await pool.query(
      'SELECT id, username, password_hash, nickname FROM users WHERE username = $1',
      [username]
    );
    
    if (result.rows.length === 0) {
      return res.status(401).json({
        success: false,
        message: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'
      });
    }
    
    const user = result.rows[0];
    
    // éªŒè¯å¯†ç 
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        message: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'
      });
    }
    
    // ç”Ÿæˆtoken
    const token = jwt.sign(
      { userId: user.id },
      process.env.JWT_SECRET!,
      { expiresIn: process.env.JWT_EXPIRE || '7d' }
    );
    
    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          username: user.username,
          nickname: user.nickname
        },
        token
      }
    });
  } catch (error) {
    console.error('ç™»å½•é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};
```

åˆ›å»º`src/routes/auth.ts`:
```typescript
import express from 'express';
import { register, login } from '../controllers/authController';

const router = express.Router();

router.post('/register', register);
router.post('/login', login);

export default router;
```

**æ­¥éª¤4: ç”¨æˆ·æ¡£æ¡ˆAPI**

åˆ›å»º`src/controllers/profileController.ts`:
```typescript
import { Response } from 'express';
import { pool } from '../config/database';
import { AuthRequest } from '../middleware/auth';

export const getProfile = async (req: AuthRequest, res: Response) => {
  try {
    const result = await pool.query(
      'SELECT * FROM user_profiles WHERE user_id = $1',
      [req.userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'ç”¨æˆ·æ¡£æ¡ˆä¸å­˜åœ¨'
      });
    }
    
    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('è·å–æ¡£æ¡ˆé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};

export const updateProfile = async (req: AuthRequest, res: Response) => {
  try {
    const {
      age, height, weight, gender, diabetes_type,
      fasting_glucose, medication, staple_food, allergies,
      meals_per_day, special_requests
    } = req.body;
    
    // åŸºæœ¬éªŒè¯
    if (!age || !height || !weight || !gender || !diabetes_type) {
      return res.status(400).json({
        success: false,
        message: 'ç¼ºå°‘å¿…å¡«å­—æ®µ'
      });
    }

    // æ£€æŸ¥æ¡£æ¡ˆæ˜¯å¦å­˜åœ¨
    const existing = await pool.query(
      'SELECT id FROM user_profiles WHERE user_id = $1',
      [req.userId]
    );
    
    if (existing.rows.length === 0) {
      // åˆ›å»ºæ–°æ¡£æ¡ˆ
      const result = await pool.query(
        `INSERT INTO user_profiles (
          user_id, age, height, weight, gender, diabetes_type,
          fasting_glucose, medication, staple_food, allergies,
          meals_per_day, special_requests
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING *`,
        [req.userId, age, height, weight, gender, diabetes_type,
         fasting_glucose, medication, staple_food, allergies,
         meals_per_day || 3, special_requests]
      );
      
      return res.status(201).json({
        success: true,
        data: result.rows[0]
      });
    } else {
      // æ›´æ–°ç°æœ‰æ¡£æ¡ˆ
      const result = await pool.query(
        `UPDATE user_profiles SET
          age = $1, height = $2, weight = $3, gender = $4,
          diabetes_type = $5, fasting_glucose = $6, medication = $7,
          staple_food = $8, allergies = $9, meals_per_day = $10,
          special_requests = $11, updated_at = CURRENT_TIMESTAMP
        WHERE user_id = $12
        RETURNING *`,
        [age, height, weight, gender, diabetes_type, fasting_glucose,
         medication, staple_food, allergies, meals_per_day,
         special_requests, req.userId]
      );
      
      return res.json({
        success: true,
        data: result.rows[0]
      });
    }
  } catch (error) {
    console.error('æ›´æ–°æ¡£æ¡ˆé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};
```

åˆ›å»º`src/routes/profile.ts`:
```typescript
import express from 'express';
import { getProfile, updateProfile } from '../controllers/profileController';
import { authenticate } from '../middleware/auth';

const router = express.Router();

router.get('/', authenticate, getProfile);
router.put('/', authenticate, updateProfile);

export default router;
```

**æ­¥éª¤5: é¥®é£Ÿè®¡åˆ’API**

åˆ›å»º`src/controllers/mealPlanController.ts`:
```typescript
import { Response } from 'express';
import { pool } from '../config/database';
import { AuthRequest } from '../middleware/auth';

export const saveMealPlan = async (req: AuthRequest, res: Response) => {
  try {
    const { plan_date, recipes } = req.body;
    
    if (!plan_date || !recipes) {
      return res.status(400).json({
        success: false,
        message: 'ç¼ºå°‘å¿…å¡«å­—æ®µ'
      });
    }

    // è®¡ç®—æ€»çƒ­é‡
    const total_calories = recipes.reduce(
      (sum: number, recipe: any) => sum + (recipe.nutrition?.calories || 0),
      0
    );
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥æ—¥æœŸçš„è®¡åˆ’
    const existing = await pool.query(
      'SELECT id FROM meal_plans WHERE user_id = $1 AND plan_date = $2',
      [req.userId, plan_date]
    );
    
    if (existing.rows.length > 0) {
      // æ›´æ–°
      const result = await pool.query(
        `UPDATE meal_plans SET
          recipes = $1, total_calories = $2, updated_at = CURRENT_TIMESTAMP
        WHERE user_id = $3 AND plan_date = $4
        RETURNING *`,
        [JSON.stringify(recipes), total_calories, req.userId, plan_date]
      );
      
      res.json({
        success: true,
        data: result.rows[0]
      });
    } else {
      // åˆ›å»º
      const result = await pool.query(
        `INSERT INTO meal_plans (user_id, plan_date, recipes, total_calories)
         VALUES ($1, $2, $3, $4)
         RETURNING *`,
        [req.userId, plan_date, JSON.stringify(recipes), total_calories]
      );
      
      res.status(201).json({
        success: true,
        data: result.rows[0]
      });
    }
  } catch (error) {
    console.error('ä¿å­˜è®¡åˆ’é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};

export const getMealPlan = async (req: AuthRequest, res: Response) => {
  try {
    const { date } = req.params;
    
    const result = await pool.query(
      'SELECT * FROM meal_plans WHERE user_id = $1 AND plan_date = $2',
      [req.userId, date]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'è¯¥æ—¥æœŸæ— é¥®é£Ÿè®¡åˆ’'
      });
    }
    
    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('è·å–è®¡åˆ’é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};

export const deleteMealPlan = async (req: AuthRequest, res: Response) => {
  try {
    const { date } = req.params;
    
    await pool.query(
      'DELETE FROM meal_plans WHERE user_id = $1 AND plan_date = $2',
      [req.userId, date]
    );
    
    res.json({
      success: true,
      message: 'åˆ é™¤æˆåŠŸ'
    });
  } catch (error) {
    console.error('åˆ é™¤è®¡åˆ’é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};
```

åˆ›å»º`src/routes/mealPlan.ts`:
```typescript
import express from 'express';
import { saveMealPlan, getMealPlan, deleteMealPlan } from '../controllers/mealPlanController';
import { authenticate } from '../middleware/auth';

const router = express.Router();

router.post('/', authenticate, saveMealPlan);
router.get('/:date', authenticate, getMealPlan);
router.delete('/:date', authenticate, deleteMealPlan);

export default router;
```

**äº¤ä»˜æ ‡å‡†**:
- æ‰€æœ‰APIæ¥å£å¯é€šè¿‡Postmanæµ‹è¯•
- æ•°æ®æ­£ç¡®ä¿å­˜åˆ°PostgreSQL
- JWTè®¤è¯æµç¨‹å®Œæ•´
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†

---

### ä»»åŠ¡4: çƒ­é‡è®¡ç®—æœåŠ¡

åˆ›å»º`src/services/calorieService.ts`:
```typescript
export interface UserProfile {
  age: number;
  height: number;
  weight: number;
  gender: 'Male' | 'Female';
}

export class CalorieService {
  /**
   * Harris-Benedict å…¬å¼è®¡ç®—åŸºç¡€ä»£è°¢ç‡(BMR)
   */
  static calculateBMR(profile: UserProfile): number {
    const { age, weight, height, gender } = profile;
    
    if (gender === 'Male') {
      return 88.362 + (13.397 * weight) + (4.799 * height) - (5.677 * age);
    }
    return 447.593 + (9.247 * weight) + (3.098 * height) - (4.330 * age);
  }

  /**
   * è®¡ç®—æ¯æ—¥ç›®æ ‡çƒ­é‡
   * @param profile ç”¨æˆ·æ¡£æ¡ˆ
   * @param activityLevel æ´»åŠ¨æ°´å¹³ (sedentary|light|moderate|active)
   */
  static calculateDailyTarget(profile: UserProfile, activityLevel = 'light'): number {
    const bmr = this.calculateBMR(profile);
    
    const activityFactors = {
      sedentary: 1.2,    // ä¹…å
      light: 1.375,      // è½»åº¦æ´»åŠ¨
      moderate: 1.55,    // ä¸­åº¦æ´»åŠ¨
      active: 1.725      // é«˜åº¦æ´»åŠ¨
    };
    
    const factor = activityFactors[activityLevel as keyof typeof activityFactors] || 1.375;
    return Math.round(bmr * factor);
  }

  /**
   * è®¡ç®—å·²æ‘„å…¥çƒ­é‡
   */
  static calculateConsumed(recipes: any[]): number {
    return recipes.reduce((sum, recipe) => {
      return sum + (recipe.nutrition?.calories || 0);
    }, 0);
  }

  /**
   * è®¡ç®—å‰©ä½™å¯æ‘„å…¥çƒ­é‡
   */
  static calculateRemaining(target: number, consumed: number): number {
    return Math.max(0, target - consumed);
  }

  /**
   * è®¡ç®—BMI
   */
  static calculateBMI(weight: number, height: number): number {
    const heightInMeters = height / 100;
    return parseFloat((weight / (heightInMeters * heightInMeters)).toFixed(1));
  }
}
```

åˆ›å»º`src/controllers/analyticsController.ts`:
```typescript
import { Response } from 'express';
import { pool } from '../config/database';
import { AuthRequest } from '../middleware/auth';
import { CalorieService } from '../services/calorieService';

export const getDashboardStats = async (req: AuthRequest, res: Response) => {
  try {
    // è·å–ç”¨æˆ·æ¡£æ¡ˆ
    const profileResult = await pool.query(
      'SELECT * FROM user_profiles WHERE user_id = $1',
      [req.userId]
    );
    
    if (profileResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'è¯·å…ˆå®Œå–„ç”¨æˆ·æ¡£æ¡ˆ'
      });
    }
    
    const profile = profileResult.rows[0];
    
    // è®¡ç®—ç›®æ ‡çƒ­é‡
    const targetCalories = CalorieService.calculateDailyTarget({
      age: profile.age,
      height: profile.height,
      weight: profile.weight,
      gender: profile.gender
    });
    
    // è·å–ä»Šæ—¥é¥®é£Ÿè®¡åˆ’
    const today = new Date().toISOString().split('T')[0];
    const mealPlanResult = await pool.query(
      'SELECT recipes FROM meal_plans WHERE user_id = $1 AND plan_date = $2',
      [req.userId, today]
    );
    
    let consumedCalories = 0;
    if (mealPlanResult.rows.length > 0) {
      const recipes = mealPlanResult.rows[0].recipes;
      consumedCalories = CalorieService.calculateConsumed(recipes);
    }
    
    // è®¡ç®—å‰©ä½™çƒ­é‡
    const remainingCalories = CalorieService.calculateRemaining(targetCalories, consumedCalories);
    
    // è®¡ç®—BMI
    const bmi = CalorieService.calculateBMI(profile.weight, profile.height);
    
    res.json({
      success: true,
      data: {
        targetCalories,
        consumedCalories,
        remainingCalories,
        bmi,
        profile: {
          age: profile.age,
          weight: profile.weight,
          height: profile.height,
          diabetesType: profile.diabetes_type
        }
      }
    });
  } catch (error) {
    console.error('è·å–ç»Ÿè®¡æ•°æ®é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯'
    });
  }
};
```

åˆ›å»º`src/routes/analytics.ts`:
```typescript
import express from 'express';
import { getDashboardStats } from '../controllers/analyticsController';
import { authenticate } from '../middleware/auth';

const router = express.Router();

router.get('/dashboard', authenticate, getDashboardStats);

export default router;
```

---

### ä»»åŠ¡5: ä¸»åº”ç”¨å…¥å£

åˆ›å»º`src/app.ts`:
```typescript
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import dotenv from 'dotenv';
import { initDatabase } from './config/initDatabase';
import { errorHandler } from './middleware/errorHandler';

// è·¯ç”±
import authRoutes from './routes/auth';
import profileRoutes from './routes/profile';
import mealPlanRoutes from './routes/mealPlan';
import analyticsRoutes from './routes/analytics';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// ä¸­é—´ä»¶
app.use(helmet());
app.use(cors({
  origin: process.env.CORS_ORIGIN?.split(',') || '*',
  credentials: true
}));
app.use(compression());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// è·¯ç”±
app.use('/api/auth', authRoutes);
app.use('/api/profile', profileRoutes);
app.use('/api/meal-plan', mealPlanRoutes);
app.use('/api/analytics', analyticsRoutes);

// å¥åº·æ£€æŸ¥
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Server is running',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV
  });
});

// 404å¤„ç†
app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: 'API endpoint not found'
  });
});

// é”™è¯¯å¤„ç†
app.use(errorHandler);

// å¯åŠ¨æœåŠ¡å™¨
async function startServer() {
  try {
    // åˆå§‹åŒ–æ•°æ®åº“
    await initDatabase();
    
    app.listen(PORT, () => {
      console.log('========================================');
      console.log('ğŸš€ æ™ºç³–ç®¡å®¶AIåç«¯æœåŠ¡å¯åŠ¨æˆåŠŸ');
      console.log(`ğŸ“Š ç¯å¢ƒ: ${process.env.NODE_ENV}`);
      console.log(`ğŸ”— åœ°å€: http://localhost:${PORT}`);
      console.log(`ğŸ“š æ–‡æ¡£: http://localhost:${PORT}/health`);
      console.log('========================================');
    });
  } catch (error) {
    console.error('âŒ æœåŠ¡å™¨å¯åŠ¨å¤±è´¥:', error);
    process.exit(1);
  }
}

startServer();
```

**é…ç½®package.jsonå¯åŠ¨è„šæœ¬**:
```json
{
  "name": "sugarsmart-backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "nodemon --exec ts-node src/app.ts",
    "build": "tsc",
    "start": "node dist/app.js",
    "db:init": "ts-node src/config/initDatabase.ts"
  }
}
```

**äº¤ä»˜æ ‡å‡†**:
- æœåŠ¡å™¨æˆåŠŸå¯åŠ¨
- æ‰€æœ‰è·¯ç”±æ­£å¸¸å·¥ä½œ
- APIå¯é€šè¿‡Postmanæµ‹è¯•

---

### ä»»åŠ¡6: AIæœåŠ¡é¢„ç•™ä¸æµ‹è¯•

**æ­¥éª¤1: åˆ›å»ºAIæœåŠ¡åŸºç¡€æ¶æ„**

åˆ›å»º`src/services/aiService.ts`:
```typescript
export interface AIGenerateRequest {
  userProfile: any;
  mealType?: string;
}

export interface AIProvider {
  generateMealPlan(request: AIGenerateRequest): Promise<any>;
  generateRecipe(request: AIGenerateRequest): Promise<any>;
}

// Mock AI Provider (å½“å‰ä½¿ç”¨)
export class MockAIProvider implements AIProvider {
  async generateMealPlan(request: AIGenerateRequest): Promise<any> {
    // è¿”å›mockæ•°æ®,ä¸å‰ç«¯ä¿æŒä¸€è‡´
    return {
      success: true,
      message: 'AIåŠŸèƒ½é¢„ç•™,å½“å‰ä½¿ç”¨mockæ•°æ®'
    };
  }

  async generateRecipe(request: AIGenerateRequest): Promise<any> {
    return {
      success: true,
      message: 'AIåŠŸèƒ½é¢„ç•™,å½“å‰ä½¿ç”¨mockæ•°æ®'
    };
  }
}

// é¢„ç•™:é€šä¹‰åƒé—®Provider
export class TongyiAIProvider implements AIProvider {
  private apiKey: string;
  private apiUrl: string;

  constructor() {
    this.apiKey = process.env.AI_API_KEY || '';
    this.apiUrl = process.env.AI_API_URL || '';
  }

  async generateMealPlan(request: AIGenerateRequest): Promise<any> {
    // TODO: å®ç°é€šä¹‰åƒé—®APIè°ƒç”¨
    throw new Error('é€šä¹‰åƒé—®APIå¾…å®ç°');
  }

  async generateRecipe(request: AIGenerateRequest): Promise<any> {
    // TODO: å®ç°é€šä¹‰åƒé—®APIè°ƒç”¨
    throw new Error('é€šä¹‰åƒé—®APIå¾…å®ç°');
  }
}

// AIæœåŠ¡å·¥å‚
export class AIService {
  private provider: AIProvider;

  constructor() {
    const providerType = process.env.AI_PROVIDER || 'mock';
    
    switch (providerType) {
      case 'tongyi':
        this.provider = new TongyiAIProvider();
        break;
      case 'mock':
      default:
        this.provider = new MockAIProvider();
    }
  }

  async generateMealPlan(request: AIGenerateRequest): Promise<any> {
    return this.provider.generateMealPlan(request);
  }

  async generateRecipe(request: AIGenerateRequest): Promise<any> {
    return this.provider.generateRecipe(request);
  }
}

export const aiService = new AIService();
```

**æ­¥éª¤2: åˆ›å»ºAPIæµ‹è¯•é›†åˆ**

åˆ›å»º`tests/api-tests.md`:
```markdown
# APIæµ‹è¯•æ¸…å•

## 1. ç”¨æˆ·è®¤è¯

### æ³¨å†Œ
POST http://localhost:3000/api/auth/register
Content-Type: application/json

{
  "username": "test_user",
  "password": "password123",
  "nickname": "æµ‹è¯•ç”¨æˆ·"
}

### ç™»å½•
POST http://localhost:3000/api/auth/login
Content-Type: application/json

{
  "username": "test_user",
  "password": "password123"
}

## 2. ç”¨æˆ·æ¡£æ¡ˆ

### æ›´æ–°æ¡£æ¡ˆ(éœ€è¦token)
PUT http://localhost:3000/api/profile
Authorization: Bearer YOUR_TOKEN_HERE
Content-Type: application/json

{
  "age": 50,
  "height": 170,
  "weight": 70,
  "gender": "Male",
  "diabetes_type": "Type 2",
  "fasting_glucose": "5.5",
  "medication": "äºŒç”²åŒèƒ",
  "staple_food": ["Rice", "Bread"],
  "allergies": ["Seafood"],
  "meals_per_day": 3,
  "special_requests": "ä½ç›é¥®é£Ÿ"
}

### è·å–æ¡£æ¡ˆ
GET http://localhost:3000/api/profile
Authorization: Bearer YOUR_TOKEN_HERE

## 3. é¥®é£Ÿè®¡åˆ’

### ä¿å­˜è®¡åˆ’
POST http://localhost:3000/api/meal-plan
Authorization: Bearer YOUR_TOKEN_HERE
Content-Type: application/json

{
  "plan_date": "2025-12-01",
  "recipes": [
    {
      "id": "1",
      "name": "ç‡•éº¦é…æµ†æœ",
      "mealType": "Breakfast",
      "time": "08:00",
      "nutrition": {
        "calories": 320,
        "carbs": 42,
        "protein": 12,
        "fat": 11,
        "giLevel": "Low"
      }
    }
  ]
}

### è·å–è®¡åˆ’
GET http://localhost:3000/api/meal-plan/2025-12-01
Authorization: Bearer YOUR_TOKEN_HERE

## 4. æ•°æ®åˆ†æ

### è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡
GET http://localhost:3000/api/analytics/dashboard
Authorization: Bearer YOUR_TOKEN_HERE
```

**äº¤ä»˜æ ‡å‡†**:
- AIæœåŠ¡æ¶æ„æ¸…æ™°
- å¯è½»æ¾åˆ‡æ¢ä¸åŒAIæä¾›å•†
- APIæµ‹è¯•æ–‡æ¡£å®Œæ•´

---

## å¼€å‘è§„èŒƒ

### ä»£ç é£æ ¼
- ä½¿ç”¨TypeScriptä¸¥æ ¼æ¨¡å¼
- éµå¾ªRESTful APIè®¾è®¡è§„èŒƒ
- æ¯ä¸ªå‡½æ•°æ·»åŠ æ³¨é‡Šè¯´æ˜
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ ¼å¼

### Gitæäº¤è§„èŒƒ
```
feat: æ·»åŠ ç”¨æˆ·è®¤è¯API
fix: ä¿®å¤æ•°æ®åº“è¿æ¥é—®é¢˜
refactor: é‡æ„çƒ­é‡è®¡ç®—æœåŠ¡
docs: æ›´æ–°APIæ–‡æ¡£
```

### å®‰å…¨è¦æ±‚
- å¯†ç å¿…é¡»åŠ å¯†å­˜å‚¨
- ä½¿ç”¨JWTè¿›è¡Œèº«ä»½éªŒè¯
- æ•æ„Ÿä¿¡æ¯ä¸æäº¤åˆ°git
- SQLæŸ¥è¯¢ä½¿ç”¨å‚æ•°åŒ–é˜²æ­¢æ³¨å…¥

---

## æµ‹è¯•ä¸éƒ¨ç½²

### æœ¬åœ°æµ‹è¯•
```bash
# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev

# æµ‹è¯•å¥åº·æ£€æŸ¥
curl http://localhost:3000/health

# åˆå§‹åŒ–æ•°æ®åº“
npm run db:init
```

### Sealoséƒ¨ç½²å‡†å¤‡
1. ç¡®ä¿.envé…ç½®æ­£ç¡®
2. ä»Sealosæ§åˆ¶å°è·å–PostgreSQLå‡­æ®
3. é…ç½®ç¯å¢ƒå˜é‡
4. è¿è¡Œ`npm run build`
5. ä½¿ç”¨`npm start`å¯åŠ¨ç”Ÿäº§æœåŠ¡å™¨

### æ•°æ®åº“è¿æ¥
```bash
# åœ¨Sealosä¸­è·å–æ•°æ®åº“ä¿¡æ¯
# å¯¼èˆªåˆ°: æ•°æ®åº“ > ä½ çš„PostgreSQLå®ä¾‹ > è¿æ¥ä¿¡æ¯

# æ›´æ–°.envæ–‡ä»¶:
DB_HOST=xxx.ns-xxx.svc.cluster.local
DB_PORT=5432
DB_NAME=sugarsmart_db
DB_USER=postgres
DB_PASSWORD=ä½ çš„å¯†ç 
```

---

## å¸¸è§é—®é¢˜

### Q1: æ•°æ®åº“è¿æ¥å¤±è´¥
**è§£å†³æ–¹æ¡ˆ**:
1. æ£€æŸ¥.envé…ç½®æ˜¯å¦æ­£ç¡®
2. ç¡®è®¤Sealosæ•°æ®åº“æœåŠ¡æ­£åœ¨è¿è¡Œ
3. éªŒè¯ç½‘ç»œè¿æ¥
4. æŸ¥çœ‹é”™è¯¯æ—¥å¿—

### Q2: JWTè®¤è¯å¤±è´¥
**è§£å†³æ–¹æ¡ˆ**:
1. ç¡®è®¤JWT_SECRETå·²é…ç½®
2. æ£€æŸ¥tokenæ˜¯å¦æ­£ç¡®ä¼ é€’
3. éªŒè¯tokenæ ¼å¼: `Bearer <token>`

### Q3: APIè¿”å›500é”™è¯¯
**è§£å†³æ–¹æ¡ˆ**:
1. æŸ¥çœ‹æœåŠ¡å™¨æ—¥å¿—
2. æ£€æŸ¥æ•°æ®åº“è¿æ¥
3. éªŒè¯è¯·æ±‚å‚æ•°æ ¼å¼

---

## æˆåŠŸæ ‡å‡†

å®Œæˆä»¥ä¸Š6ä¸ªä»»åŠ¡å,é¡¹ç›®åº”è¾¾åˆ°:
- âœ… æœåŠ¡å™¨æˆåŠŸè¿è¡Œ
- âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸
- âœ… æ‰€æœ‰æ ¸å¿ƒAPIå¯ç”¨
- âœ… JWTè®¤è¯å®Œæ•´
- âœ… çƒ­é‡è®¡ç®—å‡†ç¡®
- âœ… é”™è¯¯å¤„ç†ç»Ÿä¸€
- âœ… å¯éƒ¨ç½²åˆ°Sealos

---

## ä¸‹ä¸€æ­¥è®¡åˆ’

1. **å‰åç«¯è”è°ƒ**
   - æµ‹è¯•æ‰€æœ‰APIæ¥å£
   - éªŒè¯æ•°æ®æ ¼å¼
   - è°ƒè¯•è®¤è¯æµç¨‹

2. **AIåŠŸèƒ½æ¥å…¥**
   - å¯¹æ¥é€šä¹‰åƒé—®/æ–‡å¿ƒä¸€è¨€
   - å®ç°æ™ºèƒ½é£Ÿè°±ç”Ÿæˆ
   - ä¼˜åŒ–AIå“åº”é€Ÿåº¦

3. **æ€§èƒ½ä¼˜åŒ–**
   - æ·»åŠ Redisç¼“å­˜
   - æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
   - APIå“åº”æ—¶é—´ä¼˜åŒ–

4. **ç›‘æ§ä¸æ—¥å¿—**
   - é›†æˆæ—¥å¿—ç³»ç»Ÿ
   - æ·»åŠ æ€§èƒ½ç›‘æ§
   - é”™è¯¯è¿½è¸ª

å¼€å§‹å·¥ä½œå§!æœ‰ä»»ä½•é—®é¢˜éšæ—¶åŒæ­¥ã€‚
